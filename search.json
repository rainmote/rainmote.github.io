[{"title":"Linux使用Expect做自动化交互","url":"/2021/08/23/linux-expect-automated-interaction/","content":"\n# 背景\n在Linux进行ssh多次登录，sudo输入切换用户，打开screen/tmux时需要多次输入重复命令，思考如何解决重复性输入问题，经过探索找到了Expect脚本，其主要是用TCL语法（在网络仿真模拟中有用到过）。本文主要真对上述场景遇到的问题和基本语法做介绍，另外读者可以通过给出的资料文档进一步探索。\n\n# 简介\n维基百科: [Expect](https://en.wikipedia.org/wiki/Expect)\nSourceForge: [The Expect Home Page](http://expect.sourceforge.net)\n\n\n# TCL语法\n由于Expect是建立在TCL语言基础上的一个工具，首先看一些TCL常见语法。\n\n## 变量\n一般用于保存hostname/username/password\n\n``` bash\n# 定义一个变量\nset username \"leo\"\nset hostname \"domain.local\"\n\n# 获取命令行参数(与bash不同的是第一个参数index为0)\n## 获取第一个参数\nset hostname [lindex $argv 0]\n## 获取第二个参数\nset passwrod [lindex $argv 1]\n```\n\n## 数组\n一般用于保存服务器列表，显示并供用户选择\n\n``` bash\n# 定义一个数组\nset host_list(0) {host1 127.0.0.1 root}\nset host_list(1) {host2 192.168.1.1 admin}\nset host_list(2) {host3 8.8.8.8 dns}\n\n# 获取数组长度\nset arrlen [array size host_list]\n```\n\n## 获取用户输入\n一般用于接收用户输入选择，如密码、服务器等\n\n``` bash\n# 关闭终端回显，用于保证输入密码安全\nsystem stty -echo\n# 发送给用户，提示输入密码\nsend_user \"please input password:\"\n# 获取用户输入\nexpect_user -re \"(.*)\\n\"\n# 将用户输入存入变量\nset password $expect_out(1, string)\n# 打开终端回显\nsystem stty echo\n```\n\n## if条件分支\n用于逻辑判断\n\n``` bash\n# 判断变量是否相等，相等返回0，否则返回1\n[string compare $host \"123\"]\n\n# 获取第一个参数\nset host [lindex $argv 0]\nif ![string compare $host \"\"] { #注意化括号前必须有一个空格，具体参考TCL语言规范\n  # 如果host变量为空字符串\n}\n\nexpect_user -re \"(.*)\\n\"\nset choose $expect_out(1,string)\nif {[string compare [string toupper $choose] \"N\"] == 0} {\n  # 如果choose变量为\"N\"\n  exit\n} elseif {[scan $choose {%[0-9]} choose] == 0} {\n  # 如果choose不是数字，scan用户匹配，详情参考TCL语法\n  exit\n} elseif { $choose < 0 || $choose >= $len } {\n  # 输入非法，退出\n  exit\n}\n```\n\n## for循环\n``` bash\nset len [array size host_list]\nfor {set index 0} {$index < $len} {incr index} {\n  puts \"$index -> $host_list($index)\"\n}\n# incr为自增关键字，puts用于输出给用户，类似send_user\n```\n\n\n# Expect应用介绍\n## 接受窗口改变信号\n如果是用expect登录后，是用screen或tmux，在用户终端大小调整情况下，因为窗口大小改变信号为同步到远程服务器会导致内容错乱。\n\n``` bash\ntrap {\n  set rows [stty rows]\n  set cols [stty columns]\n  stty rows $rows columns $cols < $spawn_out(slave,name)\n} WINCH\n```\n\n## ssh自动登录\n``` bash\n# 设置timeout时间为10秒\nset timeout 10\n\n# 执行ssh命令,登录远程服务器\nspawn ssh $username@$hostname\n# 匹配服务器返回的信息\nexpect {\n  \"yes/no\" { send \"yes\\r\"; exp_continue }\n  \"passsword\" { send \"$password\\r\"; exp_continue }\n  \"$\" { send \"hostname\\r\" } # 登录后发送hostname，用于debug\n  \"Permission denied\" { send_user \"Permission denied (publickey,password).\"; exit }\n  incorrent { puts \"Invalid account or password!\"; exit }\n  timeout { puts \"Connection to $hostname timeout!\"; exit }\n  eof { puts \"Connection to $hostname failed: $expect_out(buffer)\"; exit }\n}\n\n# 检查是否登录成功\nexpect {\n  \"\\\\\\$\" { send \"whoami\\r\" }\n}\n\n# 登录screen\nsleep 0.2\nsend \"script /dev/null\\r\"\nexpect \"Script started\"\nsleep 0.2\nsend \"screen -ls\\r\"\nexpect {\n  -re \".*Detached\" { send \"screen -r $username\\r\" }\n  -re \".*Attached\" { send \"screen -x $username\\r\" }\n  -re \"/var/run/screen\" { send \"screen -dmS $username; screen -r $username\\r\" }\n}\n\n# 登录后的环境直接交给用户\ninteract\n```\n> exp_continue可以理解为for/while的continue，Expect可以看作重新执行expect匹配\n\n","tags":["自动化","效率","Devops","Linux"],"categories":["工具"]},{"title":"用Python优雅的封装Upsource HTTP API","url":"/2020/04/28/Upsource-HTTP-API-python/","content":"\n# 背景\nUpsource是一个非常出色的CodeReview工具，在和其他系统联动时需要通过API进行访问，于是使用python对其API进行封装，过程中一步一步思考如何使用python装饰器简化封装，达到十分简洁的封装。\n本文主要介绍利用动态生成函数和装饰器两种方法简化API封装的实现。\n\n# Upsource HTTP API说明\n```\nUpsource API is an RPC-style HTTP API. You can make calls using HTTP GET and POST. All data is sent and received as JSON. While the RPC methods don't enforce the use of a specific HTTP method, we recommend that you conform to HTTP semantics by using GET for retrieving data (e.g. getRevisionsList) and POST for modifying data (e.g. createReview).\n\nAll timestamps are Unix timestamps, the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT).\n\nTo invoke a method of the Upsource API using HTTP GET, make the following request:\n\nhttp://your-upsource-host/~rpc/methodName?params={JSON-encoded-params}\nTo make a POST request, use the same URL but pass the request payload in the POST body instead. A Content-Type of application/json should be set.\n```\n根据文档描述，每个接口的调用包含methodName和JSON格式的参数，于是我们开始用python进行封装。\n\n# 简单实现\n最简单的就是实现就是每个API加个函数\n```\nclass Upsource:\n    ENDPOINT = \"https://upsource.xxxx.com\"\n\n    def __init__(self, user, passwd, retry_times = 3):\n        self.__auth = HTTPBasicAuth(user, passwd)\n        self.retry_times = retry_times\n\n    # HTTP请求\n    def _request(self, rpc_name, data):\n        suffix = '/~rpc/{}'.format(rpc_name)\n        url = self.ENDPOINT + re.sub('/+', '/', suffix)\n\n        headers = {'Content-Type': 'application/json; charset=utf-8'}\n        proxies = { \"http\": \"http://127.0.0.1:8080\", \"https\": \"http://127.0.0.1:8080\"}\n        retry = self.retry_times\n\n        info('{}, request: {}'.format(rpc_name, data))\n\n        while retry > 0:\n            retry -= 1\n            resp = None\n            try:\n                resp = requests.post(url, data=json.dumps(data), auth=self.__auth, headers=headers, verify=False)\n                if resp and resp.status_code == 200:\n                    return json.loads(resp.text)['result']\n                raise Exception('request failed')\n            except Exception as e:\n                error('request upsource failed!, rpc_name: {}, request: {}, resp: {}, error:{}'.format(rpc_name, data, resp.text, str(e)))\n            time.sleep(1)\n\n    # getBranchInfo\n    def get_branch_info(self, project_id, branch):\n        data = {'projectId': project_id,\n                'branch': branch}\n        return self._request('getBranchInfo', data)\n```\n上述实现每个API都需要实现一个函数做转换，有没有优化的空间？\n下面我们介绍两种方法进行优化：\n- 动态生成函数\n- 装饰器\n\n# 动态生成函数\n## 核心思路\npython使用`locals()`可以获取当前上下文\n`exec()`可以执行在字符串中的python代码，所以可以动态生成函数，然后利用`setattr()`将生成的函数\n\n## 实现探索\n我们可以利用下划线转驼峰，将参数名的转换做优化，配合locals()获取参数列表\n下划线转驼峰函数\n```python\ndef underline2hump(underline_str):\n    return ''.join([x.capitalize() for x in underline_str.split('_') if x])\n```\n\n```python\ndef get_branch_info(project_id, branch):\n    print(locals())\n    \n>>> get_branch_info(\"123456\", \"master\")\n{'project_id': '123456', 'branch': 'master'}\n```\n于是，每个API函数可以优化成这样\n```python\ndef get_branch_info(self, project_id, branch):\n    m = locals()\n    m.pop('self')\n    data = {}\n    for k,v in iteritems(m):\n        data[underline2hump(k)] = v\n    return self._request(underline2hump(__name__), data)\n```\n函数体变成公共的了， 所以我们可以再写个公共函数，这样每个API都可以调用这个公共函数\n```python\ndef request(self, data):\n    rpc_name = sys._getframe(1).f_code.co_name\n    resp = self._request(rpc_name, data)\n    info(pprint.pformat(resp))\n    return resp\n```\n每个API函数调用`request`， 获取上一层调用名，请求参数透传；\n**注意: 这里不能用locals()，应为locals只是针对调用栈的本层命名空间，暂时没找到方法获取上一层调用函数的参数列表**\n所以每个API函数应该都有如下函数体\n```python\ndef api_name(self, params1, params2, ...):\n    m = locals();\n    m.pop('self');\n    return self.request(m);\n```\n我们可以利用python的`exec()`将字符串代码执行，这样我们就可以动态生成形如上述格式的函数，并且函数名和参数可变\n```python\nREQUEST_MAP = {\n    'getProjectInfo': ['projectId'],\n    'getCodeReviewPatterns': [],\n    'getRevisionsList': ['projectId', 'limit', 'skip = 0', 'requestGraph = False'],\n    'getRevisionsListFiltered': ['projectId', 'query', 'limit', 'skip = 0', 'requestGraph = False'],\n    'getRevisionInfo': ['projectId', 'revisionId'],\n    'getBranchInfo': ['projectId', 'branch'],\n    'getBranchGraph': ['projectId', 'branch'],\n    'getBranches': ['projectId', 'query', 'limit', 'sortBy = \"updated\"'],\n    'findCommits': ['commits', 'requestChanges = False', 'limit = 10'],\n    'getReviews': ['limit', 'query = \"*\"', 'sortBy = \"updated\"', 'projectId = \"herohub-platform\"', 'skip = 0'],\n}\n# dynamic gen class function from REQUEST_MAP\nfor k, v in self.REQUEST_MAP.items():\n    fn_str = '''def {}(self, {}): m = locals(); m.pop('self'); return self.request(m);'''.format(k, ', '.join(v))\n    info('class: {}, gen function: {}'.format(self.__class__.__name__, fn_str))\n    exec(fn_str)\n    setattr(Upsource, k, locals().get(k))\n```\n由此，我们只需要修改REQUEST_MAP就能实现API封装。\n这个实现有个小缺点：由于函数是运行时生成的，所以编辑器没法索引定义，可能导致误报。\n\n# 使用装饰器进行优化\n## 核心思路\n利用装饰器+inspect库获取函数参数名及参数值，进行参数预处理，然后进行调用\n\n## 实现探索\n```python\nimport inspect\n\ndef request(func):\n    def wrapper(*args, **kw):\n        print(\"locals: {}\".format(locals()))\n        print(\"args: {}\".format(args))\n        print(\"kw: {}\".format(kw))\n        spec = inspect.getfullargspec(func)\n        print(spec)\n        \n        data = {}\n        for idx, k in enumerate(spec.args):\n            if idx >= len(args):\n                break\n            data[k] = args[idx]\n            \n        for idx, k in enumerate(spec.args[len(args):]):\n            data[k] = spec.defaults[idx]\n            \n        method = getattr(data['self'], 'request_internal')\n        self = data.pop('self')\n        return method(func.__name__, data)\n    \n    return wrapper\n\nclass HttpRequestWrap:\n    def __init__(self):\n        pass\n    \n    def request_internal(self, name, data):\n        print(\"call request, name: {}, data: {}\".format(name, data))\n        \n    @request\n    def get_branch_info(self, project_id, branch_name):\n        pass\n    \n    @request\n    def get_branch_info2(self, project_id, branch_name=''):\n        pass\nh = HttpRequestWrap()\nh.get_branch_info(\"123456\", \"master\")\nlocals: {'args': (<__main__.HttpRequestWrap object at 0x10fd5b450>, '123456', 'master'), 'kw': {}, 'func': <function HttpRequestWrap.get_branch_info at 0x10fd5a4d0>}\nargs: (<__main__.HttpRequestWrap object at 0x10fd5b450>, '123456', 'master')\nkw: {}\nFullArgSpec(args=['self', 'project_id', 'branch_name'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={})\ncall request, name: get_branch_info, data: {'project_id': '123456', 'branch_name': 'master'}\n\nh.get_branch_info2(\"123456\")\nlocals: {'args': (<__main__.HttpRequestWrap object at 0x10fd5b450>, '123456'), 'kw': {}, 'func': <function HttpRequestWrap.get_branch_info2 at 0x10fd5a680>}\nargs: (<__main__.HttpRequestWrap object at 0x10fd5b450>, '123456')\nkw: {}\nFullArgSpec(args=['self', 'project_id', 'branch_name'], varargs=None, varkw=None, defaults=('',), kwonlyargs=[], kwonlydefaults=None, annotations={})\ncall request, name: get_branch_info2, data: {'project_id': '123456', 'branch_name': ''}\n```\n\n# 完整代码\n## 动态生成\n```python\n#!/usr/local/bin/python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport re\nimport time\nimport requests\nimport json\nimport pprint\nfrom requests.auth import HTTPBasicAuth\n\nimport urllib3\nurllib3.disable_warnings()\n\nfrom log import debug, info, warning, error, fatal\n\nclass Upsource:\n    ENDPOINT = \"https://upsource.xxxx.com\"\n\n    REQUEST_MAP = {\n        'getProjectInfo': ['projectId'],\n        'getCodeReviewPatterns': [],\n        'getRevisionsList': ['projectId', 'limit', 'skip = 0', 'requestGraph = False'],\n        'getRevisionsListFiltered': ['projectId', 'query', 'limit', 'skip = 0', 'requestGraph = False'],\n        'getRevisionInfo': ['projectId', 'revisionId'],\n        'getBranchInfo': ['projectId', 'branch'],\n        'getBranchGraph': ['projectId', 'branch'],\n        'getBranches': ['projectId', 'query', 'limit', 'sortBy = \"updated\"'],\n        'findCommits': ['commits', 'requestChanges = False', 'limit = 10'],\n        'getReviews': ['limit', 'query = \"*\"', 'sortBy = \"updated\"', 'projectId = \"herohub-platform\"', 'skip = 0'],\n    }\n\n    def __init__(self, user, passwd, retry_times = 3):\n        self.__auth = HTTPBasicAuth(user, passwd)\n        self.retry_times = retry_times\n\n        # dynamic gen class function from REQUEST_MAP\n        for k, v in self.REQUEST_MAP.items():\n            fn_str = '''def {}(self, {}): m = locals(); m.pop('self'); return self.request(m);'''.format(k, ', '.join(v))\n            info('class: {}, gen function: {}'.format(self.__class__.__name__, fn_str))\n            exec(fn_str)\n            setattr(Upsource, k, locals().get(k))\n\n    def _request(self, rpc_name, data):\n        suffix = '/~rpc/{}'.format(rpc_name)\n        url = self.ENDPOINT + re.sub('/+', '/', suffix)\n\n        headers = {'Content-Type': 'application/json; charset=utf-8'}\n        proxies = { \"http\": \"http://127.0.0.1:8080\", \"https\": \"http://127.0.0.1:8080\"}\n        retry = self.retry_times\n\n        info('{}, request: {}'.format(rpc_name, data))\n\n        while retry > 0:\n            retry -= 1\n            resp = None\n            try:\n                resp = requests.post(url, data=json.dumps(data), auth=self.__auth, headers=headers, verify=False)\n                if resp and resp.status_code == 200:\n                    return json.loads(resp.text)['result']\n                raise Exception('request failed')\n            except Exception as e:\n                error('request upsource failed!, rpc_name: {}, request: {}, resp: {}, error:{}'.format(rpc_name, data, resp.text, str(e)))\n            time.sleep(1)\n\n    def request(self, data):\n        rpc_name = sys._getframe(1).f_code.co_name\n        resp = self._request(rpc_name, data)\n        info(pprint.pformat(resp))\n        return resp\n\n    def getAllProjects(self, projectIdList):\n        return self.request({'projectId': projectIdList})\n\nif __name__ == '__main__':\n    up = Upsource('admin', '123456')\n    up.getProjectInfo(\"herohub-platform\")\n    up.getReviews(1000, 'branch:feature/20200316 and state: open')\n```\n\n\n\n","tags":["编程","python","upsource"],"categories":["python"]},{"title":"路漫漫其修远兮，吾将上下而求索","url":"/2019/09/12/current/","content":"\n{% pullquote mindmap mindmap-md %}\n- 我的探索\n  - 绘图\n    - 文本绘图\n      - mermaid: 封装graphviz\n      - GraphEasy: 生成ascii流程图，很酷且高效\n  - 值得你了解的工具\n    - Marp: 使用markdown写ppt\n    - Notion: 迄今为止最好用的笔记软件\n    - Anytype: 仿照notion，以web3为基础，开源，可私有部署\n    - \bHammerspoon: MAC上强大的自动化工具\n      - 使用lua封装了系统层api，可以非常简单、高效实现自动化\n      - 功能包括且不限于：\n        - 窗口管理（多屏幕移动）\n        - 剪贴板\n        - 全局快捷键\n        - 自动化脚本\n        - 控制wifi/蓝牙\n        - dock显示信息，资讯/githubPR/天气预报\n        - ……\n      - 可以让你少买很多软件;用了就无法自拔的神器\n    - spacehammer: 一个好用的Hammerspoon的配置库\n      - 使用仿clojure的Fennel语言编写，利用Lisp强大的表达能力，语法非常简洁优美\n      - 仿spacemacs的操作方式，上手十分简单，处处有提示\n    - Kodi: 家庭影音中心\n      - 可以配置直播源，有网就能看电视，可以配置全球电视源\n      - 可以集成app，直接访问网络资源，如优酷，百度云等\n      - Mac上安装，局域网看视频；支持丰富的视频格式\n      - 一个树莓派，让普通电视智能化\n  - 智能家居\n    - NAS\n    - HomeAssistant\n    - 硬件设备\n      - 小米系列\n      - 峥果：浴霸,墙壁开关改造的最佳之选\n  - 编程\n    - 语言推荐\n      - clojure\n      - haskell\n    - 工具\n      - shellcheck: 你的shell脚本老师\n      - postgrest: pg数据的cp，直接提供restAPI\n  - Devops\n    - CI\n      - jenkins\n      - gerrit\n    - CD\n      - k8s\n    - Other\n      - airflow\n\n{% endpullquote %}\n\n# 我的状态\n## 2020年\n### 01月\n#### 智能家居\n- 将峥果浴霸刷上开源的固件，接入homeassistant；单火墙壁开关固件dump出来，尝试分析\n- 小米万能遥控器音箱，拆卸找到ttl，无法用过ttl进入shell，可能封堵了串口gettty，待继续探索解决方案\n- 春节~.~\n\n### 02月\n#### 效率工具\n- Mac升级，键盘映射失效，shift切换中英文失效，折腾时顺便捡起了hammerspoon；spacehammer真是相见很晚的库，可以用“Clojure”来写mac自动化工具，兴奋至极！\n\n### 03月\n#### 小米音箱万能遥控版折腾\n- 年前沟通了一台本来打算接入homeassistant，奈何网上都是小爱版，没有带红外功能的；拆解ttl连接无法进入shell，从信息可以得到芯片是全志A33，尝试从FEL模式提取固件失败。\n\n#### IPFS\nFilecoin今年即将迎来主网上线，作为区块链在web3.0时代重要应用之一，未来必将成为一大热门，所以提前关注。了解ipfs，关注社区动态。\n\n### 11月\n家里新买了加湿器和踢脚线，想着用红外传感器接入HA做控制，淘宝上买了模组，刷入开源固件，能够测试通过，但是便捷性不高；另外对于温湿度的反馈也依赖了设备是否有红外反馈，踢脚线的有红外响应但是无法解析，还待进一步研究。\n后来买了BroadLink RM PRO4万能遥控器，能够控制但是无法得到反馈，使用过程无法温度设置了多少，湿度设置了多少，还待进一步折腾。\n\n## 2021年\n### 07月\n学习Mac逆向相关技术\n\n<!-- 访问非常慢\n<iframe width=\"1200\" height=\"800\" frameborder=\"0\" src=\"https://www.mindmeister.com/maps/public_map_shell/1327105969/_?width=1200&height=800&z=auto&t=NjbQUruQ8W\" scrolling=\"no\" style=\"overflow: hidden; margin-bottom: 5px;\">您目前的浏览器无法显示框架元素。请访问MindMeister上的<a href=\"https://www.mindmeister.com/1327105969/_?t=NjbQUruQ8W\" target=\"_blank\">我的技能树</a>页面。</iframe><div class=\"mb-5\"><a href=\"https://www.mindmeister.com/1327105969/_?t=NjbQUruQ8W\" target=\"_blank\">我的技能树</a> 作者 <a href=\"https://www.mindmeister.com/users/channel/39950735\" target=\"_blank\">rainmote</a></div>\n-->"},{"title":"2018年度学习总结","url":"/2019/01/23/2018-learning-summay/","content":"\n# 2018年度业余学习总结\n\n回首2018，时间如此之快；今年工作之余的学习也有较多收获，故予以总结，一来以便回顾查漏补缺，二来制定明年学习计划。\n\n备注：本篇只总结业余时间的学习，工作相关的不便公开。\n\n# 年度知识关键词\n\nClojure DNS协议 数据可视化 IoT数字电路 移动端开发 NAS 全栈 Postgresql 黎曼猜想\n\n# 学习总结\n\n## clojure\n\n学习使用clojure+clojurescript进行全栈开发，实现了单页面应用基本网站架构，和较为复杂的页面查询。完成了两个网页：工作的一些测试工具展示；自己的个人工具集网站。\n<!-- more -->\n\n### cljsrn\n使用clojurescript+react native编写app，计划做个手机APP来将照片加密上传存储在OSS或者S3，目前进度是完成了初步的页面，主要的加密、上传功能还没有开始做。\n\n### 使用**gloss**库进行网络协议开发\n\n为了获取单个域名CDN节点，想法是搜集全国的DNS服务器，然后向这些DNS服务发起查询请求，得到CDN节点。由于DNS协议比较奇葩，目前gloss库对这种可变头部决定后续内容，目前实现了构造数据包，对于响应包解析还存在问题，目前gloss库作者已经不再维护，后续有时间可以再研究下这个问题。\n\n### luminus\nclojure luminus非常好用， 可以直接生成一个包含各个组件的应用。\n\n[http://www.luminusweb.net/](http://www.luminusweb.net/)\n\n书写自己的工具时使用了postgresql，发现其非常好用，不仅和mongodb一样，支持存储json格式，而且和mysql一样， 是关系型数据库。\n\n### 管道数据流思想\n[https://github.com/linpengcheng/PurefunctionPipelineDataflow](https://github.com/linpengcheng/PurefunctionPipelineDataflow)\n\n使用该思想，可以方便的将代码结构简化，但是入门时还是总是会不自觉的将代码复杂度提高，需要不断练习、体会。\n\n## IoT\n\nIoT本年度主要思考智能家居方面，从去年的尝试模拟身份证ID，想着直接拆解室内终端，尝试监听电路信号，模拟重放开门信号；发现了数字分析仪，于是购买了Digilent OpenScope MZ，直接连接在线路上，没做任何保护，结果就是烧毁了。\n\n后来又发现了物美价廉的DsLogic数字分析仪，于是入手一个，采集信号后，利用树莓派模拟发现信号电压不够，多试了几次发现树莓派也被烧毁了……\n\n和同学聊天中知晓了些电路知识，发现自己这块还是空白，于是找了麻省理工的数字电路公开课，学习第一节就明显感觉牛逼学校教授知识确实很赞，从基本的电路知识，一层一层介绍了后续知识的拓展，描绘出了数字电路一层一层抽象发展出的计算机学科。\n\n# 好用的工具\n\n- Explainshell\n\n好用的Linux命令参数解释工具，对于复杂命令可以拆解理解。\n\n示例:\n[https://explainshell.com/explain?cmd=git+log+--all+--graph+--decorate+--oneline+--simplify-by-decoration](https://explainshell.com/explain?cmd=git+log+--all+--graph+--decorate+--oneline+--simplify-by-decoration)\n\n- graph-easy\n\n生成ascii图形，相比较graphviz，可以方便生成ascii图形，对于利用github搭建的静态博客，图片存储很麻烦，所以写博客时使用ascii图形表达更加方便。\n\n- outline\n\ngoogle的母公司出品，包装了ss，傻瓜式安装、配置、管理，多平台，非常方便。\n\n[https://www.getoutline.org/](https://www.getoutline.org/)（需要梯子）\n\n- Notion\n\n用过的最好的笔记软件\n\n# Other\n\n## 黎曼猜想\n\n黎曼猜想被证明可谓是一大新闻。\n\n业余买了两本相关书籍，大概了解了黎曼猜想讲了什么，但是其中很多概念不了解。\n\n比如虚数，之前学习的时候记得规定i的平方是-1，但是为什么是这样的呢？当查阅资料了解更多时，就会发现数学发展与人类进步密切相关。\n\n从最开始的正整数1、2、3……，到加入0后的自然数，再到负数，然后到有理数（3/5等），接着到无理数（根号2），已经到了实数域。\n\n可以将复数看作为一种工具，它的引入是为了解决问题。那么为什么是引入这样的，而不是那样的？\n\n关于复数的引入，可在网上找到很多文章\n\n比如：[http://www.ruanyifeng.com/blog/2012/09/imaginary_number.html](http://www.ruanyifeng.com/blog/2012/09/imaginary_number.html)。\n\n# 总结\n2018年相比2017年学到的东西深入了一点，这一年业余主要写clojure，但是很多项目都比较零碎，目前正在做的就是一个自己工具，将零碎的小工具整合，主要实现web页面，方便使用管理。\n工作上的事情也颇多，较为好的一点是做自己擅长且喜欢的工作了，心里压力小了很多；这也是利用业余时间能够学习更多的原因。\n\n新的一年，继续整理自己工具，写clojure，折腾智能家居，顺便看看那些年不知道的所以然（数学为什么是这样的？），^_^\n","tags":["年度总结"],"categories":["总结"]},{"title":"用Clojure将git log解析为json格式","url":"/2018/12/14/git-log-format-to-json/","content":"\n# 背景\n有时我们需要分析git提交历史，而git log支持--format选项，无法直接输出json，所以需要自己包装下。\n[git-log文档](https://git-scm.com/docs/git-log)\n\n# 实现\n本示例使用`clojure`实现，我们可以看到其简洁、优美之处。\n\n<!--more-->\n\n## 定义format选项\n格式化参数可以参考git log文档，\n```clojure\n(defn get-git-log-params []\n  {:commit \"%H\"\n   :abbreviated-commit \"%h\"\n   :tree \"%T\"\n   :abbreviated-tree \"%t\"\n   :parent \"%P\"\n   :abbreviated-parent \"%p\"\n   :refs \"%D\"\n   :encoding \"%e\"\n   :subject \"%s\"\n   :body \"%b\"\n   :commit-notes \"%N\"\n   :author-name \"%aN\"\n   :author-email \"%aE\"\n   :author-date \"%ai\"\n   :author-timestamp \"%at\"\n   :committer-name \"%cN\"\n   :committer-email \"%cE\"\n   :committer-date \"%ci\"\n   :committer-timestamp \"%ct\"})\n```\n\n## 格式化方式选择\n我们需要格式化为json格式，format支持自定义格式，我们有两种方式可以选择：\n1. format参数直接包装为json格式\n此种方式每个commit之后需要加个空格，最末尾的需要去除。\n优点：直接得到json\n缺点：某些字段内容包含引号，转义问题不容易解决\n\n2. 利用特殊分隔字符\n我们将每个输出参数分隔，再将每个commit输出分隔，拿到输出后进行解析。\n优点：不用考虑转义问题\n缺点：实现略微复杂\n不过我们利用`clojure`可以很方便实现。\n\n## 需要用的小知识点\n```clojure\n;; 字符串切分\nuser=> (clojure.string/split \"a#&b#&c\" (re-pattern \"#&\"))\n[\"a\" \"b\" \"c\"]\n\n;; key和value组合为map\nuser=> (into {} (mapv vector [:a :b :c] [1 2 3]))\n{:a 1, :b 2, :c 3}\n\n;; map拆分为ks vs\nuser=> (apply mapv vector (seq *1))\n[[:a :b :c] [1 2 3]]\n```\n\n## 实现步骤\n### 定义分割符\n```clojure\n(def magic-item \"&=&=&=&=&=&=\")\n(def magic-line \"#@#@#@#@#@#@\")\n```\n\n### 拆分参数并构造命令\n```clojure\n;; 这里用到了参数解构，线性宏\n(let [[ks vs] (apply mapv vector (seq (get-git-log-params)))]\n  (-> (clojure.string/join magic-item vs)\n      (str ,,, magic-line)\n      (#(format \"git log remotes/origin/%s --format='%s'\" branch-name %) ,,,)))\n```\n\n### 执行shell命令\n```clojure\nuser=> (require '[clojure.java.shell :as shell])\nnil\nuser=> (->> (shell/sh \"bash\" \"-c\" \"date\") :out)\n\"Fri Dec 14 08:28:00 CST 2018\\n\"\n```\n这里使用`bash -c`是个小技巧，后面的命令可以可以放在一个字符串中处理。\n\n### 解析结果\n假设我们完成了上述步骤，将会得到如下格式的输出：\n```\naaa&=&=&=&=&=&=bbb&=&=&=&=&=&=ccc#@#@#@#@#@#@123&=&=&=&=&=&=456&=&=&=&=&=&=789\\n\n```\n我们需要按照如下步骤解析：\n1. 删除末尾换行\n2. 按照行分隔符切分\n3. 每行再按照列分隔符切分\n4. 组合key和切分后的内容\n\n具体实现如下：\n```clojure\n(->> (clojure.java.shell/sh \"bash\" \"-c\"\n                   (-> (clojure.string/join magic-item vs)\n                       (str ,,, magic-line)\n                       (#(format \"git log remotes/origin/%s --format='%s'\" branch %) ,,,))\n                  :dir code-path)\n     :out\n     clojure.string/trim-newline\n     ;; split output to line\n     (#(clojure.string/split % (re-pattern magic-line)) ,,,)\n     ;; split line to item\n     (map #(clojure.string/split % (re-pattern magic-item)) ,,,)\n     ;; combination ks and output into map\n     ;; [:a :b] [1 2] => {:a 1 :b 2}\n     (map #(into {} (mapv vector ks %)) ,,,)\n     ;; convert to json\n     (cheshire.core/generate-string ,,,))\n```\n> 我们将默认的map改用pmap，即可多核并行处理，clojure就是如此简单。\n\n# 完整实现\n见 [https://github.com/rainmote/blog-example/blob/master/git-log.clj](https://github.com/rainmote/blog-example/blob/master/git-log.clj)\n","tags":["clojure","git","编程"],"categories":["工具"]}]